<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tmux 简明指南]]></title>
    <url>%2F2017%2F11%2F03%2FTmux-Guide%2F</url>
    <content type="text"><![CDATA[Tmux 做为一利器，很早就知道了，但是一直没有搞明白其使用场景，甚至一直在以错误的方式使用。现今花点时间搞明白它。 首先就是使用场景的问题，至于具体的命令以后在慢慢记忆。 ¶ 使用场景 在远程机器上安装和使用 tmux。一般使用 SSH 登陆到远程机器上后，若 SSH 断开后，在重新登陆，但是原先的窗口中的输出啊什么的就看不到了。若 SSH 登陆后，使用 tmux 命令开启一个会话，就算 SSH 断开了，你在重新登陆后，直接 attach 到原先的会话，就回到了原先的工作现场。而且在会话的窗口中可以使用 tmux 的快捷键开启多个面板，不需要在来一个 SSH 连接过去了。在 SSH 登陆的时候，使用 ssh user@host &quot;command&quot; 或 ssh user@host -- command，直接在远程机器上执行命令，如 tmux。 在本地机器上安装使用 tmux。在本地使用的话，可以方便的分屏，在会话和终端中切换，减少窗口数量等。这些iTerm2 就可以啦，一般还是在远程机器上使用。不过 detach 后，倒是可以变相的隐藏窗口… ¶ Tmux 的使用 Ctrl + b，然后 d，就会从当前会话中分离，回到原先终端。在原先终端中 tmux attach，就可以来到原先的会话。 在 tmux 的会话中，按下 Ctrl + b 后是激活控制台，输入 ? 可以显示控制台命令帮助。 如果有多个会话，可以使用 tmux ls 查看，然后 tmux attach -t sessionname 进入到这个会话。 命令可以查看这个 CheatSheet ¶ Mac 上和 iTerm2 的集成 如果本地机器使用的是 iTerm2，在 SSH 远程连接中使用 tmux -CC 命令，一个新的 tmux 会话就会被创建，并会开启一个新的窗口，而且 iTerm2 会接管 tmux 的功能，如分屏，就无需使用 tmux 的命令来进行了，可直接在这个新的窗口中使用 iTerm2 的快捷键，还有如历史查找等快捷键，也没必要对远程机器进行单独配置这些了。关闭某个面板时，选择 Hide，就可以使用 tmux -CC attach 命令来 attach 了。这个依然是使用场景1。 在 iTerm2 的 Preferences &gt; general 中有一项 tmux Integration，可以对集成的 tmux 进行一些设置，如打开新窗口做为本地 tab，执行 tmux -CC attach 后，隐藏本窗口等。 使用 mosh 替代 ssh，mosh 会自动断开重连，需要在两端都安装。不过若使用 mosh 的连接，使用 -CC 参数无反应。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 之多态的实现]]></title>
    <url>%2F2017%2F10%2F15%2FJVM-Polymorphism%2F</url>
    <content type="text"><![CDATA[这部分的笔记在国庆假期前就整理好了，然后说再加工一下，放到 blog 上，毕竟笔记只是适合自己看，没有很强的逻辑性。但每个假期回来后，都会患上一定的假期综合征，总需要几天收收心。就一直拖到现在，简直无可救药。 OOP 的三大特征：封装、继承、多态。以前记忆的时候都是不分先后，随便记忆的，加深理解后才知道这三个特性是一个递进的过程。最后的多态是在继承的基础之上的。 这里先从 JVM 方法调用说起，最后在得出多态的概念。 ¶ 方法调用指令 在 JVM 中有四个主要的方法调用指令： invokestatic invokespecial invokevirtual invokeinterface 在 Class 文件中，这些方法调用指令后面跟着的是要调用方法的符号引用。这些符号引用最终都要在类加载阶段或运行期转化为直接引用。 其中 invokestatic 和 invokespecial 这两个指令调用的方法称为解析调用，是一个静态过程， 在编译期间就完全确定。要调用方法的符号引用在运行时常量池中已经在类加载的解析阶段被解析为了方法的直接引用，就不需要在运行期去方法表中查找了。这些方法有静态方法、私有方法、实例构造器，称为非虚方法。 其中 invokestatic 用于调用静态方法，invokespecial 用于调用私用方法和实例构造器。此外虽然被 final 修饰的方法是使用 invokesvirtual 来调用的，但由于 final 方法无法被子类覆写，只存在唯一版本，所以也是一种非虚方法。这也是这些方法无法被继承或覆写在 JVM 的体现。 而 invokesvirtual 和 invokeinterface 这两个指令调用的方法称为分派调用，是在运行期才能确定正确的目标方法，得到直接引用。而分派调用又分为静态分派和动态分派。 ¶ 分派调用 分派都是通过方法的符号引用去运行时常量池中去查找得到方法所属类型（即调用该方法的引用变量所属类型，是静态类型）及方法名和描述符，然后根据方法名和描述符去所属类型的方法表中查找确定该方法的目标版本，进而得到方法的直接引用。 ¶ 静态分派 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。 在 Java 中的体现就是方法重载，在编译阶段，编译器会根据参数的静态类型决定使用哪个重载版本，完全发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。只是在运行期间去静态类型的方法表中查找该方法，从而得到该方法的直接引用。 ¶ 动态分派 相对于静态分派，动态分派是在运行期根据实际类型来确定方法执行版本的分派过程称为动态分派。 在 Java 中的体现就是方法的覆写。因为实际类型在运行期间可随着程序变化，因此只能在在运行期间才能确定一个对象的实际类型是什么，编译时编译器并不知道，只知道静态类型是什么。那就需要动态的分派目标方法执行版本。这个过程就是重写的本质 但是针对 invokevirtual 和 invokeinterface 两个指令，动态分派的具体过程是不同的： invokevirtual，实例调用，调用对象的实例方法。动态的分派目标方法执行版本是先在静态类型方法表中找到目标方法并得到偏移量，根据栈帧中对象的引用得到这个对象，在从对象中指向方法区类信息和运行时常量池的引用得到对象的实际类型的类信息，然后在得到的类信息方法表相同偏移量的位置查找目标方法 invokeinterface, 接口方法调用，在运行时再确定一个实现此接口的对象。因为一个类可以实现多个接口，相当于多继承。所以就不能按照偏移量去实现类的方法表中查找了，只能通过搜索完整的方法表。 不管是动态分派还是静态分派，我们发现都离不开一个关键的东西方法表，最终都是通过方法表进行索引从而得到方法的直接引用。因此方法表是实现动态分派的一个关键。 ¶ 方法表 JVM 在完成类加载后，会将这个 class 文件二进制字节流转化为虚拟机所需格式存储在方法区中，称为类信息，类信息就是类文件在运行时的数据结构，包含了该类中所有定义的信息。 类信息中包含有一个方法表，方法表中包括从父类（一直到 Object 类）继承的所有实例方法（不包含私有方法，因为私有方法不能继承）以及自身覆写的方法的直接引用，这些直接引用指向类信息中相应的方法代码。 如果是本类的方法或者是覆写了父类的方法，则指向的是本类类信息中相应的方法代码；如果是父类的方法，则指向的是父类类信息中的方法代码。这样通过方法表中方法的引用就可以访问到该类到根类的所有实例方法。 方法表是 JVM 用来提高搜索查找目标方法性能的一个实现。invokevirtual 执行时用到的方法表是虚方法；invokeinterface 用到的方法表是接口方法表。为了程序上实现的方便，具有相同签名的方法，在父类、子类的虚方法表中都具有一样的索引号，因此才可直接使用偏移量在实际类型的方法表中进行查找。 ¶ 多态 那么什么是多态呢，一般的书籍都是把多态分为两种： 编译时多态，通过方法的重载体现，是静态分派 运行时多态，通过方法的覆写体现，是动态分派 因为重载是静态分派，因此也可以说重载不算是多态的一个体现，但并不妨碍我们的理解。 多态还可以从不同的角度进行定义，如在语法上是子类继承父类并覆写了父类的方法，父类引用指向子类对象。在 OOP 里是 Java 引入了多态性的概念是为了弥补因为单继承而带来的一些不足，如接口也是在一定程度上为了可以使用多继承。 另外重载和覆写说的都是方法，只有类中的方法才有多态的概念，类中的成员变量和内部类并没有此概念。静态方法也没有多态的概念，和成员变量取值与父类还是子类一样，都是由引用变量的静态类型决定的。也因此可以说静态方法并不能被覆写。 ¶ 参考 内容主要来自 《深入理解 Java 虚拟机》第八章。都是自己理解后总结的，难免有错误之处，以后慢慢修正。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 之常量池]]></title>
    <url>%2F2017%2F09%2F30%2FJVM-CP%2F</url>
    <content type="text"><![CDATA[最近在看周志明的《深入理解 Java 虚拟机》这本书，不得说，学习 JVM 对更深层次理解 Java 有很大的帮助，两者互相印证。像打通了任督二脉一般，对 OOP 和 语法这块为什么要这么设计，语法为什么要这么写豁然开朗，融汇贯通后也更便于记忆这些知识点。 文章大多摘自自己的 Wiki JavaBasics，都是对知识点的总结，加上自己的理解后一条条写下的。难免有很多理解错误的地方，自己前前后后也纠正了不少，也是一个学习的过程。 关于常量池这块，本来就知道一个字符串常量池，可是看了 JVM 后，又冒出了好几个常量池，顿时懵逼了。看了大量资料，理解后总结出了这么点知识。 ¶ 常量池的划分 Class 文件常量池 运行时常量池 字符串常量池 ¶ Class 文件常量池 Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 什么是字面量和符号引用呢，为了理解这两个概念，只能啰嗦的写了。 这里的字面量是指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；声明为final的常量值指的是成员变量，不包含本地变量，本地变量是属于方法的。这些都在常量池的 UTF-8 表中(逻辑上的划分) 符号引用，就是指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用 ¶ 运行时常量池 运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。 一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。 可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。 ¶ 字符串常量池 在 jdk1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的实例 在 jdk1.7（含）之后，是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中 jdk1.8 已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用 字符串常量池是全局的，JVM 中独此一份，因此也称为全局字符串常量池。 运行时常量池中的字符串字面量若是成员的，则在类的加载初始化阶段就使用到了字符串常量池；若是本地的，则在使用到的时候（执行此代码时）才会使用到字符串常量池。 其实，“使用常量池”对应的字节码是一个 ldc 指令，在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（jdk1.7)。String 类的 intern() 方法还可在运行期间把字符串放到字符串常量池中。 JVM 中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。 ¶ 总结 理解了这部分后，后面才能更容易的理解 JVM 中方法的调用，多态的实现等。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>常量池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 安全引导机制分析和绕过测试]]></title>
    <url>%2F2017%2F09%2F30%2FBypass-QCOM-Secure-Boot%2F</url>
    <content type="text"><![CDATA[上半年为了学位写了一篇论文，今天把它转成了 markdown 格式，便于分享。全文在我的 Wiki里，算是全文吧，去除了很多论文必须的废话。并把其中的干货拿出来放到这里。 文章对高通的安全引导机制进行了简单分析，并在小米一款机器上综合漏洞成功绕过了其安全引导机制,达到自由修改系统分区的目的。 ¶ Android安全引导流程和组成 ¶ Android安全引导流程 一台 Android 设备是由硬件和软件组成，当按下开机键时系统从硬件到软件，在到最后进入 Android 系统，是一个完成的引导过程。以高通为例，在一个常规的引导过程中，CPU 引导芯片代码 PBL（Primary Boot Loader，类似于 x86 的 BIOS，有时也被成为 BootROM）从预定义的地方（固化在 ROM）开始执行，PBL由高通做好后烧写在芯片中，不可更改，是 RoT（Root of Trust，信任根）。使用烧录在fuse中的根公钥校验并加载引导程序 SBL1（Secondary Boot Loader），跳转到 sbl1 执行，SBL1 加载校验 APPSBL（aboot），最后 APPSBL 加载校验 boot 分区[1]。内核启动后，会通过内核中的 dm-verity[2] 功能模块校验系统分区的完整性。这样就完成了整个系统的安全引导。整个流程如图所示[3]： 目前 Android 一个完整的校验过程，分为两部分： 一分部是官方的 verified boot，由内核中的 dm-verity 来确保 system 分区没有经过被篡改 另一部分是针对于不同设备的引导加载程序的安全引导来验证最终 boot 镜像的完整性。这两部分共同建立了一个从 bootloader 到系统镜像的信任校验链 ¶ Android安全引导组成 ¶ 引导加载程序的安全引导 这个过程是一个安全认证校验链，都是由上一阶段的程序加载校验下一阶段的要执行的程序，通过签名校验机制，来确保系统不被经过任何形式的篡改，只执行制造商的固件。此过程是特定于设备的，通常通过使用不可更改的特定于硬件的密钥来实现被“烧录”（写入只写存储器）到设备中。该密钥用于验证每级的引导加载程序到最终boot镜像的完整性。 高通的 bootloader 是开源项目，在 Android 代码树的 bootable/bootloader/lk 下可以看到它的代码。是针对特定的主板与芯片编写的，并不是Android操作系统的一部分。由于 SBL 代码是闭源代码，分析起来是一个复杂的过程。论文在分析研究引导加载程序的安全引导过程中只从 APPSBL 开始进行分析。 Bootloader 是 OEM 厂商或者运营商加锁和限制的地方。当 bootloader 上锁后就不允许在非解锁状态下对手机固件进行修改或者刷第三方系统。这些限制取决于 OEM 和运营商的具体决策，可能会有所不同，但普遍都会采用密码学的签名校验机制来阻止设备被刷机或者执行未经合法签名的代码。如果用户想要刷机就需要先对 bootloader 进行解锁。现 OEM 都会采用专门的机制，比如需向官方申请解锁码，申请通过后得到解锁码才可以解锁设备。设备解锁后 bootloader 将不再对 boot 和 recovery 分区进行签名校验，也就是不在进行安全引导，允许进行刷机和清除用户数据等操作。 后面的章节还将会针对高通的 LK 的签名和校验 机制进行解剖分析，研究具体的安全保护措施，分析存在的安全缺陷和隐患。 ¶ Verified Boot 从版本 4.4 起，Android 支持使用 Linux 的 Device-Mapper[4] 框架中的 dm-verity 功能进行验证启动。Dm-verity 是为块完整性检查而设计开发，使用加密散列树提供块设备的透明完整性检查。它可以验证每个设备块在从磁盘读取时的完整性，如果块检出，则读取成功; 如果没有，读取会产生 I/O 错误，就好像块被实际损坏了一样。在 Android 中用来保护系统重要分区如 system 分区或 vendor 分区的完整性。系统分区被挂载为只读模式，不再允许被挂载为读写模式。校验系统分区时使用的密钥在 boot 镜像的 ramdisk 中。 论文后面的章节还将会继续分析 Verified Boot 在 Android 上的具体实现，研究存在的安全缺陷和隐患。 ¶ Android安全引导机制及缺陷分析 ¶ 引导加载程序引导机制分析 ¶ user keystore校验漏洞挖掘 Bootloader 序是一种专门的，特定于硬件的程序，当设备首次通电（ARM 设备复位时）执行。其目的是初始化设备硬件，提供最小的设备配置接口，然后找到并启动操作系统。引导设备通常需要经历不同的阶段，这涉及每个阶段的单独的引导加载程序，本文只分析 APPSBL（aboot）加载引导程序。Android 引导加载程序通常是专有的，特定于芯片 SoC 的系统。设备和 SoC 制造商在其引导加载程序中提供不同的功能和级别的保护。 在整个校验链中由aboot来提供验证 boot.img 的完整性，其开源代码 LK 可在 Code Aurora Forum 下载。在 LK 中有两个可用于校验的不同的密钥： 一个是 oem_keystore，被编译到 aboot 中，定义在 platform/msm_shared/include/oem_keystore.h 一个是 user_keystore 存储在 keystore 分区中 引导过程中始终尝试使用 OEM keystore 来验证 boot.img 和 recovery.img。但在 keystore 分区不为空的时候，会使用 OEM keystore 对其签名进行验证，如果验证通过，将从里面读取 user_keystore，然会用其验证 boot.img 和 recovery.img。 user_keystore 包含了用于验证的 RSA 公钥。以 CAF 代码 LA.BR.1.3.2_rb3.14分支为例，整个基本函数和逻辑执行如图所示： 最终调用的 verify_image_with_sig() 采用的是 user_keystore中的公钥进行校验。而 user_keystore 的值由 boot_verifier_init 调用 read_oem_keystore，将 oem_keystore 赋值 user_keystore。接着对 keystore 分区进行验证，如果验证通过，则将分区中的数据赋值 user_keystore。这样就完成了对 user keystore 的利用。 但是 read_user_keystor() 方法中调用 verify_keystore 验证 user keystore 时，在 if-else 判断中的 385 行因缺少花括号，导致无论验证成功与否，都会 user_keystore 进行赋值。具体代码如图所示： 这样就造成了一个明显的安全漏洞，user keystore 不用经过 OEM 的签名也可以用于校验 boot 或 recovery 镜像。我们只需要自己签名生成 keystore.img 通过其它漏洞写入手机就可以绕过安全引导机制。 ¶ 解锁标记位的保护分析 在高通的分区表中，有一个名为 devinfo 的分区，大小 1024K。在 app/aboot/devinfo.h 中定义了其数据结构，包括了 is_unlocked 解锁状态标记位；is_tampered 篡改标记位等。通过 fastboot oem device-info 命令可以获取相关信息。 在 LK 启动时，通 aboot\_init()-&gt;read_device_info(&amp;device)-&gt;read_device_info_mmc() 读取，若 is_unlock 为 true，就跳过校验，允许执行 flash 命令等。使用 fastboot oem unlock 命令后，会通过 write_device_info_mmc(&amp;device) 对 devinfo 分区的标记位进行操作。 高通源代码中并为对该标记位进行加密签名等保护，直接修改标记位就可以使用对手机的解锁。但是在 OEM 的实现中，大多都会对该分区进行保护，修改分区名和使用加密签名等手段，保证分区不被非法篡改。 但 Android 碎片化的存在，厂商技术的参差不齐，依然有很多设备未对该部分进行修改，留下了安全漏洞。 ¶ 高通下载模式分析 高通有着自己的下载协议，一般在设备生产的时候通过该协议烧录固件。在 lk 代码 aboot_init 中，通过监控按键等操作可以选择到进入到不同的模式，如 recovery 或 fastboot 模式等。代码中默认当同时按下音量上下键时，则进入到 DLOAD 模式，也就是下载模式。然后通过高通专有的 sahara 或 firehose 协议工具进行固件的下载更新[5]。 同样在 kernel/drivers/power/reset/msm-poweroff.c 中相关代码由宏 CONFIG_MSM_DLOAD_MOD 控制，可开启或关闭是否可以通过 adb reboot edl/dload 命令重启进入到下载模式。 高通的升级工具及协议在下载的过程中，并不会对固件进行任何的校验，如果下载了错误或损坏的固件，则直接会让设备变砖。但是，厂商为方便开发、生产、售后等需求，并不会完全关闭掉高通的下载模式，有的会留下隐蔽的接口来进入到该模式。 ¶ Android的Verified Boot ¶ Dm-verity概述 Dm-verity 使用加密散列树提供块设备的透明完整性检查，每个块以 4k 的大小来划分，都有一个 SHA256 的值。树中的每个节点是加密 hash，其中叶节点包含物理数据块的 hash，并且中间节点包含其子节点的 hash。因为根节点中的哈希是基于所有其他节点的值，所以只有根哈希需要被信任才能验证树的其余部分。对任何一个节点块的改动都破坏整个加密 hash。整个哈希树的结构如图所示： 验证时使用包含在 boot 分区中的 RSA 公钥来执行。设备块在运行时通过计算读取的块的哈希值并将其与散列树中的记录值进行比较来检查。如果值不匹配，则读取操作将导致 I/O 错误，指示文件系统已损坏。因为所有的检查都是由内核执行的，所以启动过程需要验证 boot.img 的完整性，以便验证引导工作。 在 Android 中被校验的分区始终挂载为只读状态，只能在 OTA 块设备升级时才可做更改。其它任何对分区的操作都会破坏分区的完整性，比如 root 等操作。 ¶ 在Android中的实现方法 Dm-verity device-mapper 目的最初是为了在 Chrome 操作系统中实现验证启动而开发的，并且已经在 Linux 内核的 3.4 版本中集成。它使用 CONFIG_DM_VERITY 内核配置项来进行开关。 但 Android 的具体实现方式和 Chrome 有所不同。用于验证的 RSA 公钥在 boot 镜像的 ramdisk 中，文件名是 verity_key，用于验证目标设备的 root hash 签名。被验证的目标分区，有着一个包含了哈希表和它自身签名的元数据块，被附加到镜像的最后。如果要启用对某一分区的校验，需要在 ramdisk 中的 fstab 文件中对特定设备添加 verify 标签[6]。 当系统启动过程中，检测到该标签，则会使用 verity_key 公钥加载校验该分区最后附加的元数据。如果签名验证通过，则文件系统管理器解析 dm-verity 映射表，并将其传递给 Linux 设备映射器，设备映射器使用映射表中包含的信息来创建虚拟的 dm-verity 块设备。然后将该虚拟块设备安装在 fstab 中指定的安装点上，代替相应的物理设备。因此，所有读自底层物理设备的数据都会用预先生成的散列树进行透明验证。对设备任何修改或添加文件，甚至将分区重新挂载为读写都会导致完整性验证和 I/O 错误。虚拟设备的挂载如图所示： 但是因为具体的实现方式原因，用于校验的 RSA 公钥 verity_key，直接被放在了 ramdisk中。这给了替换该公钥文件进行攻击的可能性。而且对目标设备是否进行校验，也直接用明 verify 签进行判断，这也是一个明显的安全缺陷。 ¶ 启用Verified Boot 在谷歌的官方文档描述中，要完全启用 verified boot，除了要配置整个编译系统开启相关选项，还需要引导加载程序实现相关对boot镜像的完整性校验。上节已经针对高通 SoC 在这块的实现进行了分析研究。 AOSP 源代码中，开发 key 包括公钥和私钥，它们位 build/target/product/security/ 目录。用来给 boot/recovery/system 镜像签名，以及验证 system 分区的真实性元数据块表[7]。在启用 verified boot 时需要生成自己的公私钥，但某些机型设备依然是使用的默认的密钥，这相当于是导致了密钥的泄露，对设备来说没有任何安全性可言了。 ¶ 漏洞利用测试和安全加固 ¶ 利用漏洞绕过安全引导 ¶ 攻击方法的设计 在上一章中分析了存在安全缺陷和漏洞。利用自签名的 user keystore 和 boot/recovery 镜像，并且在 boot 的 ramdis k中移除对 system 分区的进行校验的 verify 标记。或者替换 ramdisk 中的verity_key，并对 system 镜像进行签名。刷写到手机中，就能实现绕过某些机型的安全引导机制，对设备进行自由修改。 但是在设备处于 LOCKED 状态时，是无法通过 fastboot 进行刷写操作的。但是 OEM 一般都会预留自己的下载模式，比如三星的 ODIN，联发科的 SP Flashtool。而高通 SoC 则是上一章中分析到的 dload/edl 模式，该模式在固件镜像下载过程中并不做任何的校验，直接能刷写进去。 本文测试机器是 红米Note3 全网通版，系统的版本为 V7.2.3.0，Android 版本 6.0,内部开发代号 kenzo。Kenzo 在几次的升级后，逐渐关闭了按键进入，adb reboot dload/edl 重启进入下载模式的途经，开启了 dm-verity，来保护手机不被破解和刷机。但是通过IDA Pro逆向分析 aboot 分区中的 emmc_appsboot.mbn 引导加载程序镜像时，发现了 reboot-edl的命令。如图所示： 正如其命名一样，是标准 fastboot 协议是不支持此命令的，为此需要修改 fastboot 源码。fastboot 源代码在 AOSP 源码树 system/core/fastboot 中。分析 fastboot 源码，命令最后是通过 fb_queue_command 发送给 bootloader，修改代码添加对该命令的支持。然后就能成功的重启到 edl 模式。核心代码示例如图所示： ¶ 漏洞利用测试过程 整个测试过程是为了验证本文对安全引导机制进行分析研究后挖掘出的相关安全漏洞，达到在设备处于 LOCKED 状态时，篡改并修改设备，绕过 Android 安全引导机制。过程如下： 生成自己的公私钥对 利用公私钥对生成并签名 keystore.img 对 boot.img 重新打包，移除 system 分区 verify flag 对 boot.img 进行重新签名 使用修改后的 fastboot，执行fastboot reboot-edl进入下载模式 使用 emmcdl[8] 工具分别刷入 keystore.img boot.img 若设备能成功开启，则证明完全绕过了 Android 的安全引导机制。System 分区也不在不挂载为虚拟设备，而是真实的物理设备块。如图所示： 在手机预装行业中，还会对 system 分区镜像进行篡改，然后利用上面的过程也刷写到手机中。同样也可以修改 devinfo 分区的标记位，强制修改手机的状态。这样有了一套对该机型进行刷机预装的方案。 ¶ 参考 Tecent. Android系统典型bootloader分析 ↩ Milan Broz. dm-verity: device-mapper block integrity checking target ↩ laginimaineb. Unlocking the Motorola Bootloader ↩ Red Hat Inc. Device-Mapper Resource Page ↩ CSDN. 高通 MSM8K bootloader 之二：SBL1 ↩ Google. dm-verity ↩ CSDN. QualComm Android boot recovery vertify ↩ Github. emmcdl ↩]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Secure Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[少了一条腿的大蜘蛛]]></title>
    <url>%2F2017%2F09%2F29%2FShamballa-hike-photo%2F</url>
    <content type="text"><![CDATA[少了一条腿的大蜘蛛，摄于九月中旬西山香巴拉中途]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>西山</tag>
        <tag>香巴拉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始使用 Hexo]]></title>
    <url>%2F2017%2F09%2F28%2Fmigrate-to-hexo-md%2F</url>
    <content type="text"><![CDATA[这几天看到一个主题，自己非常中意。 一看是 Hexo 下的，早前就想切到这个框架下，但拖延症严重，一直未动手。恰好赶上这个时机，自己又闲来无事，遂动手。 都是些琐碎的配置工作，自己的文章又不多，索性一篇篇的来修改，又把以前没注意的一些排版上的问题给纠正下。主要添加了一个以前没接触过的 leancloud 的统计。 把以前感觉略中二的博客名字也改了，改为 Sunyata, 中文译文 “空性” 倒是和守望先锋里的和尚禅雅塔发音相似，意思也相近。 不过 Disqus 的评论给丢了，本就不多，有时间就迁移过来。]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用一加3做 WIFI 中继器]]></title>
    <url>%2F2017%2F04%2F18%2Foneplus3-as-wifi-repeater%2F</url>
    <content type="text"><![CDATA[隔壁学校的 wifi 网络不错，但是因为离得远，信号差，只能在窗户边能连得上。买了一个 360 wifi 中继器，但速度掉的厉害，而用手机直接连接网速倒是正常，就想着把手机作为 wifi 中继器。记得自己的第一台 android 手机，中兴 v880 当时是支持 wifi 中继的，一边连着 wifi，一边扩展 wifi 信号，后来才知道那算是中兴特有的。找了一圈，并没有找到这样的 APP，fqrouter2 倒是有这个功能，但是作者已经停止维护，在我手机上直接启动失败。参考 fqrouter2 的文章和脚本终于让 oneplus3 STA+AP 一起工作了。 ¶ 使用一加3做 wifi 中继器脚本配置 ONEPLUS A3000 系统 cm-13.0, Android 6.0.1 root 权限 iw iwlist wpa_cli 等二进制文件 一加3 采用的是QCA6164A wifi 芯片，支持 802.11ac，最高有 434M 带宽。 系统本身自带的便携式 WLAN 热点功能，只能分享移动数据的网络，不能够做为一个 wifi repeater，开启时自动关闭 wifi 连接和 wpa_supplicant进程，并开启 hostapd 进程来提供 AP。 但系统支持 WIFI Direct 功能，也就是说设备在连接着 wifi 的时，可以开启一个热点，其它设备可以通过这个热点加入到 P2P group 中。但是 WIFI Direct 不支持手动设置密码，连接外网等。 查看网卡设备信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230root@oneplus3:/data/local/tmp # iw phyWiphy phy3 max # scan SSIDs: 10 max scan IEs length: 500 bytes max # sched scan SSIDs: 0 max # match sets: 0 Retry short limit: 7 Retry long limit: 4 Coverage class: 0 (up to 0m) Device supports roaming. Device supports T-DLS. Supported Ciphers: * WEP40 (00-0f-ac:1) * WEP104 (00-0f-ac:5) * TKIP (00-0f-ac:2) * 00-40-96:254 * 00-40-96:255 * CCMP-128 (00-0f-ac:4) * WPI-SMS4 (00-14-72:1) * CMAC (00-0f-ac:6) Available Antennas: TX 0 RX 0 Supported interface modes: * IBSS * managed * AP * P2P-client * P2P-GO Band 1: Capabilities: 0x9072 HT20/HT40 Static SM Power Save RX Greenfield RX HT20 SGI RX HT40 SGI No RX STBC Max AMSDU length: 3839 bytes DSSS/CCK HT40 L-SIG TXOP protection Maximum RX AMPDU length 65535 bytes (exponent: 0x003) Minimum RX AMPDU time spacing: 16 usec (0x07) HT Max RX data rate: 72 Mbps HT TX/RX MCS rate indexes supported: 0-7 Bitrates (non-HT): * 1.0 Mbps * 2.0 Mbps * 5.5 Mbps * 11.0 Mbps * 6.0 Mbps * 9.0 Mbps * 12.0 Mbps * 18.0 Mbps * 24.0 Mbps * 36.0 Mbps * 48.0 Mbps * 54.0 Mbps Frequencies: * 2412 MHz [1] (20.0 dBm) * 2417 MHz [2] (20.0 dBm) * 2422 MHz [3] (20.0 dBm) * 2427 MHz [4] (20.0 dBm) * 2432 MHz [5] (20.0 dBm) * 2437 MHz [6] (20.0 dBm) * 2442 MHz [7] (20.0 dBm) * 2447 MHz [8] (20.0 dBm) * 2452 MHz [9] (20.0 dBm) * 2457 MHz [10] (20.0 dBm) * 2462 MHz [11] (20.0 dBm) * 2467 MHz [12] (20.0 dBm) * 2472 MHz [13] (20.0 dBm) * 2484 MHz [14] (disabled) Band 2: Capabilities: 0x9072 HT20/HT40 Static SM Power Save RX Greenfield RX HT20 SGI RX HT40 SGI No RX STBC Max AMSDU length: 3839 bytes DSSS/CCK HT40 L-SIG TXOP protection Maximum RX AMPDU length 65535 bytes (exponent: 0x003) Minimum RX AMPDU time spacing: 16 usec (0x07) HT Max RX data rate: 72 Mbps HT TX/RX MCS rate indexes supported: 0-7 VHT Capabilities (0x000003b2): Max MPDU length: 11454 Supported Channel Width: neither 160 nor 80+80 RX LDPC short GI (80 MHz) TX STBC VHT RX MCS set: 1 streams: MCS 0-7 2 streams: MCS 0-7 3 streams: MCS 0-7 4 streams: MCS 0-7 5 streams: MCS 0-7 6 streams: MCS 0-7 7 streams: MCS 0-7 8 streams: MCS 0-7 VHT RX highest supported: 0 Mbps VHT TX MCS set: 1 streams: MCS 0-7 2 streams: MCS 0-7 3 streams: MCS 0-7 4 streams: MCS 0-7 5 streams: MCS 0-7 6 streams: MCS 0-7 7 streams: MCS 0-7 8 streams: MCS 0-7 VHT TX highest supported: 0 Mbps Bitrates (non-HT): * 6.0 Mbps * 9.0 Mbps * 12.0 Mbps * 18.0 Mbps * 24.0 Mbps * 36.0 Mbps * 48.0 Mbps * 54.0 Mbps Frequencies: * 4920 MHz [184] (disabled) * 4940 MHz [188] (disabled) * 4960 MHz [192] (disabled) * 4980 MHz [196] (disabled) * 5040 MHz [8] (disabled) * 5060 MHz [12] (disabled) * 5080 MHz [16] (disabled) * 5180 MHz [36] (23.0 dBm) * 5200 MHz [40] (23.0 dBm) * 5220 MHz [44] (23.0 dBm) * 5240 MHz [48] (23.0 dBm) * 5260 MHz [52] (23.0 dBm) (radar detection) * 5280 MHz [56] (23.0 dBm) (radar detection) * 5300 MHz [60] (23.0 dBm) (radar detection) * 5320 MHz [64] (23.0 dBm) (radar detection) * 5500 MHz [100] (disabled) * 5520 MHz [104] (disabled) * 5540 MHz [108] (disabled) * 5560 MHz [112] (disabled) * 5580 MHz [116] (disabled) * 5600 MHz [120] (disabled) * 5620 MHz [124] (disabled) * 5640 MHz [128] (disabled) * 5660 MHz [132] (disabled) * 5680 MHz [136] (disabled) * 5700 MHz [140] (disabled) * 5720 MHz [144] (disabled) * 5745 MHz [149] (30.0 dBm) * 5765 MHz [153] (30.0 dBm) * 5785 MHz [157] (30.0 dBm) * 5805 MHz [161] (30.0 dBm) * 5825 MHz [165] (30.0 dBm) * 5852 MHz [170] (disabled) * 5855 MHz [171] (disabled) * 5860 MHz [172] (disabled) * 5865 MHz [173] (disabled) * 5870 MHz [174] (disabled) * 5875 MHz [175] (disabled) * 5880 MHz [176] (disabled) * 5885 MHz [177] (disabled) * 5890 MHz [178] (disabled) * 5895 MHz [179] (disabled) * 5900 MHz [180] (disabled) * 5905 MHz [181] (disabled) * 5910 MHz [182] (disabled) * 5915 MHz [183] (disabled) * 5920 MHz [184] (disabled) Supported commands: * new_interface * set_interface * new_key * start_ap * new_station * set_bss * join_ibss * set_pmksa * del_pmksa * flush_pmksa * remain_on_channel * frame * frame_wait_cancel * set_channel * tdls_mgmt * tdls_oper * testmode * channel_switch * connect * disconnect Supported TX frame types: * IBSS: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0 * managed: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0 * AP: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0 * P2P-client: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0 * P2P-GO: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0 Supported RX frame types: * IBSS: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0 * managed: 0x40 0xd0 * AP: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0 * P2P-client: 0x40 0xd0 * P2P-GO: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0 WoWLAN support: * wake up on anything (device continues operating normally) * wake up on disconnect * wake up on magic packet * wake up on pattern match, up to 4 patterns of 6-64 bytes, maximum packet offset 0 bytes * can do GTK rekeying * wake up on GTK rekey failure * wake up on EAP identity request * wake up on 4-way handshake * wake up on rfkill release software interface modes (can always be added): valid interface combinations: * #&#123; managed &#125; &lt;= 3, total &lt;= 3, #channels &lt;= 2 * #&#123; managed &#125; &lt;= 1, #&#123; IBSS &#125; &lt;= 1, total &lt;= 2, #channels &lt;= 1 * #&#123; AP &#125; &lt;= 2, total &lt;= 2, #channels &lt;= 2 * #&#123; P2P-client &#125; &lt;= 1, #&#123; P2P-GO &#125; &lt;= 1, total &lt;= 2, #channels &lt;= 2 * #&#123; managed &#125; &lt;= 2, #&#123; AP &#125; &lt;= 1, total &lt;= 3, #channels &lt;= 2, STA/AP BI must match * #&#123; managed &#125; &lt;= 2, #&#123; P2P-client, P2P-GO &#125; &lt;= 2, total &lt;= 4, #channels &lt;= 2, STA/AP BI must match * #&#123; managed &#125; &lt;= 2, #&#123; P2P-GO &#125; &lt;= 1, #&#123; AP &#125; &lt;= 1, total &lt;= 4, #channels &lt;= 2, STA/AP BI must match Device supports HT-IBSS. Device supports scan flush. 该芯片是支持这些功能 123456Supported interface modes: * IBSS * managed * AP * P2P-client * P2P-GO 12345678910111213root@oneplus3:/ # iw devphy#0 Interface p2p0 ifindex 24 wdev 0x2 addr c2:ee:fb:d6:08:0d type managed Interface wlan0 ifindex 23 wdev 0x1 addr c0:ee:fb:d6:08:0d ssid BIUBIU_5G type managed 网卡有两个 interface，默认启用了 p2p 接口，但开启系统的热点功能后 12345678root@oneplus3:/ # iw devphy#1 Interface wlan0 ifindex 27 wdev 0x100000001 addr c0:ee:fb:d6:08:0d ssid ONEPLUS A3000 type AP p2p0 端口消失，只剩下了 wlan0 端口，查看 hostapd 进程的 cmdline 12root@oneplus3:/ # cat /proc/11047/cmdline/system/bin/hostapd -e /data/misc/wifi/entropy.bin /data/misc/wifi/hostapd.conf 先前的 wpa_supplicant 进程是 123root@oneplus3:/ # cat /proc/11257/cmdline/system/bin/wpa_supplicant -ip2p0- Dnl80211 -c/data/misc/wifi/p2p_supplicant.conf -I/system/etc/wifi/p2p_supplicant_overlay.conf -N -iwlan0 -Dnl80211 -c/data/misc/wifi/wpa_supplicant.conf -I/system/etc/wifi/wpa_supplicant_overlay.conf -O/data/misc/wifi/sockets -puse_p2p_group_interface=1 -e/data/misc/wifi/entropy.bin wpa_supplicant 同时管理着 p2p0 wlan0 两个 interface，p2p0 interface 的状态 12345root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0 statuswpa_state=DISCONNECTEDp2p_device_address=c2:ee:fb:d6:08:0daddress=c2:ee:fb:d6:08:0duuid=4227ede7-6911-52a9-987c-6ce45048dfe1 处于未连接状态，使用 wpa_cli 直接添加一个固定的 p2p 分组， wpa_cli 支持交互模式。进行此操作之前，备份一下 /data/misc/wifi/p2p_supplicant.conf，防止出错 123456789101112131415161718192021222324252627282930313233343536root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0wpa_cli v2.5-devel-6.0.1Copyright (c) 2004-2015, Jouni Malinen &lt;j@w1.fi&gt; and contributorsThis software may be distributed under the terms of the BSD license.See README for more details.Interactive mode&gt; add_network0&gt; set_network 0 mode 3OK&gt; set_network 0 disabled 2OK&gt; set_network 0 ssid &quot;loopax&quot;OK&gt; set_network 0 key_mgmt WPA-PSKOK&gt; set_network 0 proto RSNOK&gt; set_network 0 pairwise CCMPOK&gt; set_network 0 psk &quot;12345678&quot;OK&gt; save_configOK&gt; list_networknetwork id / ssid / bssid / flags0 loopax any [DISABLED][P2P-PERSISTENT]&gt; p2p_group_add persistent=0OK&lt;3&gt;P2P-GROUP-STARTED p2p-p2p0-0 GO ssid=&quot;loopax&quot; freq=5765 passphrase=&quot;12345678&quot; go_dev_addr=c2:ee:fb:d6:08:0d [PERSISTENT]&gt; quit 此时，热点就起来了 12345678910111213141516171819root@oneplus3:/ # iw devphy#3 Interface p2p-p2p0-0 ifindex 33 wdev 0x300000003 addr c2:ee:fb:d6:88:0d ssid loopax type P2P-GO Interface p2p0 ifindex 32 wdev 0x300000002 addr c2:ee:fb:d6:08:0d type managed Interface wlan0 ifindex 31 wdev 0x300000001 addr c0:ee:fb:d6:08:0d ssid BIUBIU_5G type managed 起来了一个新的接口 p2p-p2p0-0，type 是 P2P-GO, 该接口状态 1234567891011121314root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p-p2p0-0 statusbssid=c2:ee:fb:d6:88:0dfreq=5765ssid=loopaxid=0mode=P2P GOpairwise_cipher=CCMPgroup_cipher=CCMPkey_mgmt=WPA2-PSKwpa_state=COMPLETEDip_address=192.168.49.1p2p_device_address=c2:ee:fb:d6:08:0daddress=c2:ee:fb:d6:88:0duuid=4227ede7-6911-52a9-987c-6ce45048dfe1 热点可以正常连接，但是不能够上网，也 ping 不通 IP，开启设备的网络转发 和 NAT 12345root@oneplus3:/ # echo 1 &gt; /proc/sys/net/ipv4/ip_forwardroot@oneplus3:/ # iptables -Froot@oneplus3:/ # iptables -P INPUT ACCEPTroot@oneplus3:/ # iptables -P FORWARD ACCEPTroot@oneplus3:/ # iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE 这样 ip 就能 ping 的通了，但是 DNS 还是不正常，连接热点的设备手动设置 DNS 的话，就可以正常上网了。重启系统的 dnsmasq，让 DHCP 自动分配 DNS 123root@oneplus3:/ # killall dnsmasqroot@oneplus3:/ # /system/bin/dnsmasq --no-resolv --no-poll --dhcp-authoritative --server=114.114.114.114 --dhcp-option-force=43,ANDROID_METERED --pid-file --dhcp-range=192.168.49.2,192.168.49.254,1h 这样就是配置了一个完整的 wifi 中继了。 再次开启中继只需 1root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0 p2p_group_add persistent=0 然后在配置网络转发，和 iptables、 dhcp。 默认两个接口是使用同样的 channel，但是也是可以指定频道的,如 1root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0 p2p_group_add persistent=0 freq=5825 获取 channel 信息 1234567891011121314151617181920212223242526272829root@oneplus3:/ # iwlist wlan0 channelwlan0 26 channels in total; available frequencies : Channel 01 : 2.412 GHz Channel 02 : 2.417 GHz Channel 03 : 2.422 GHz Channel 04 : 2.427 GHz Channel 05 : 2.432 GHz Channel 06 : 2.437 GHz Channel 07 : 2.442 GHz Channel 08 : 2.447 GHz Channel 09 : 2.452 GHz Channel 10 : 2.457 GHz Channel 11 : 2.462 GHz Channel 12 : 2.467 GHz Channel 13 : 2.472 GHz Channel 36 : 5.18 GHz Channel 40 : 5.2 GHz Channel 44 : 5.22 GHz Channel 48 : 5.24 GHz Channel 52 : 5.26 GHz Channel 56 : 5.28 GHz Channel 60 : 5.3 GHz Channel 64 : 5.32 GHz Channel 149 : 5.745 GHz Channel 153 : 5.765 GHz Channel 157 : 5.785 GHz Channel 161 : 5.805 GHz Channel 165 : 5.825 GHz Current Frequency:5.765 GHz (Channel 153) 可在 /data/misc/dhcp/dnsmasq.leases 文件中查看连接的客户端。 ¶ 参考 无线中继启动的条件 使用手机做无线中继的可能性探寻 联想P770手机（MTK6577）无线中继脚本配置方法 wifi repeater start script PATCH]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Openwrt-x86</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为 EMUI 5.0 root 方法]]></title>
    <url>%2F2016%2F12%2F21%2Fhuawei-EMUI50-rootway%2F</url>
    <content type="text"><![CDATA[华为 EMUI 5.0 root 方法和分析 ¶ 华为 EMUI5.0 获取 root 方法 华为EMUI5.0 目前 root 方法是刷TWRP，然后使用 TWRP 刷入 Chainfire 的 SuperSU 或者 phh 的 Superuser。你需要支持 Nougat 版本的 TWRP，但是在刷入 Chainfire 的 SuperSU 过程中会直接导致设备重启，因为 SuperSU 的工作原理是在采用 systemless 时无论在刷入还是开机过程中都需要 mount 一个 loop 设备 su.img，猜测是华为的 kernel 做了限制，当 mount 一个 loop 设备时设备会直接重启最后进入到 erecovery. 使用 phh 的 Superuser 则无此问题，但是默认提供的 Superuser 版本是开启了 dm-verity 和 forceencrypt，因为 dm-verity 的存在导致获取到的 root 权限是不完整的，无法对 system 分区做任何修改，所以自己修改了一个 Superuser-r275 的版本，关闭了这两个开关. 同时也借鉴 phh 的做法，将 SuperSU 相关 su 文件放到 ramdisk 下并移除 su.img 的创建和挂载过程，最后对 sepolicy 重新打 patch，这部分脚本完全来自 phh 的 Superuser. 但是因此也失去了 SuperSU 特有的一些功能，例如 frp 和 app 内更新二进制的功能，升级版本只能通过重刷来解决. 至于最终到底是不是华为 kernel的限制，还是需要等华为开源时，才能最终解决. ¶ FRD-AL00 root 所需文件 自己测试的机器是荣耀8 FRD-AL00 版本，需要到的文件： frd-twrp SuperSU phh Superuser 该 recovery 应该也同样适用于华为P9,或者其他的 hi3650 机器.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>root</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成用于 Verifiedboot 的 system.img]]></title>
    <url>%2F2016%2F07%2F05%2Fbuid-verifiedboot-system-image%2F</url>
    <content type="text"><![CDATA[Android 从 6.0 开始启用了 Verifiedboot，来保证系统的完整性 ¶ GetVerityTreeSize 和 GetVerityMetadataSize build_verity_tree -s 2046820352 build_verity_metadata.py -s 2046820352 该两个方法在源码的 ./tools/releasetools/build_image.py 中. 参数是真实 system 分区的大小 ¶ 生成预留空间的 system.simg 要重新打包 system.simg 给 verity_tree 和 verity_metadata 预留出空间，-l指定的大小为真实 system 空间的大小减去上一步分别得到的大小 ¶ 生成 root_hash 即 verity_tree build_verity_tree -A aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7 system.simg verity.img 其中 aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7 是 salt，system.simg 需要是 sparse image，生成 verity.img. 命令输出例子 3a82cfc74206a6a8b467fb699022d86ea36dee48b04fc8b40585d2cad941f463 aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7 第一个就是后面要用到的 root_hash 值。 ¶ 生成 verity_metadata build_verity_metadata.py 2030665728 verity_metadata.img 3a82cfc74206a6a8b467fb699022d86ea36dee48b04fc8b40585d2cad941f463 aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7 /dev/block/platform/msm_sdcc.1/by-name/system verity_signer verity.pk8 其中第一个参数是预留了空间后的 system 大小，后面的分别是 root_hash、salt、system 分区在手机里的分区、signer_path、私钥。最后生成 verity_metadata.img，32768 个字节 32kb 是固定值。 ¶ 生成最终的 image append2simg system.simg verity_metadata.img append2simg system.simg verity.img 分别是前两步中生成的文件。 ¶ 参考 Android secrue boot]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>verifiedboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采用 LVM 扩展 Home 分区]]></title>
    <url>%2F2016%2F07%2F05%2Fuse-lvm-spread-home-partition%2F</url>
    <content type="text"><![CDATA[电脑是双系统，从windows下压缩出了部分空间，来扩展ubuntu的home分区 ¶ 创建lvm sudo apt-get install lvm2 sudo fdisk /dev/sda,新建分区后，输入t，输入要改变分区类型的分区号，输入8e，最后w保存。 sudo partprobe 重读分区表,此时可能需要重启一下，要不下面一步会提示not found. sudo pvcreate /dev/sda4 创建物理卷PV，让刚刚的分区可用 sudo pvdisplay 查看PV sudo vgcreate ext_vol /dev/sda4 创建逻辑卷组VG，创建完毕之后，可以在/dev/下面看见设备 sudo vgdisplay 查看VG sudo lvcreate --name home --size 48G ext_vol 创建逻辑卷分区LV，创建完毕之后，就可以在/dev/ext_vol/下看见分区了，然后这个分区就可以操作了 或者sudo lvcreate --name home -l +100%FREE 48G ext_vol,使用全部空间 sudo lvdisplay sudo mkfs.ext4 /dev/ext_vol/home 格式化 然后就可以挂载使用了 ¶ 迁移home分区 进入rescue mode模式，把原先的home分区挂载到/home目录下，把/dev/ext_vol/home挂载到/home1目录下，操作前要让分区可写mount -o remount rw /,然后cp -afR /home/* /home1,最后修改/etc/fstab自动挂载。 ¶ 将原先的home分区也添加到lvm中 修改分区类型为8e 重载分区表 格式化 创建PV sudo vgextend ext_vol /dev/sda8 #扩展逻辑卷组ext_vol sudo lvextend -l +100%FREE /dev/ext_vol/home 扩容LV的home分区，使用全部的VG空间 再次进入rescue mod模式下，resize2fs /dev/ext_vol/home ¶ 参考 Linux LVM硬盘管理及LVM扩容 Ubuntu Server上的LVM配置]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于高通 9008 刷机的研究]]></title>
    <url>%2F2015%2F09%2F01%2Fabout-qcom-edl-dload-study%2F</url>
    <content type="text"><![CDATA[¶ 生成所需xml ¶ GPT 分区 parse_gpt 根据官方 GPT 文件解析出具体的 GPT 的分区信息并生成对应平台的 partiiton.xml 文件，最后通过 ptool.py 生成可刷写的配置文件 rawprogram0.xml、patch0.xml 跟最后的 GPT。 官方的 gpt 文件一般需要经过裁剪,一般裁剪成 17408 字节大小，包括文件头开始的 512 字节的 MBR 信息 dd if=gpt.bin of=gpt-new.bin bs=17408 count=1,然后使用 ./parse_gpt gpt-new.bin，输出在 GPT_DUNP_FILES 中。 或者在手机中 dd if=/dev/block/mmcblk0 of=/sdcard/gpt-new.bin bs=17408 count=1，为配合 parse_gpt,大小一般为 17408/34304。 ¶ MBR 分区 上面所说的是 GPT 分区的，但是一些老平台的机器依然使用的是 MBR 分区，例如 msm7x30 和 msm8x60 平台 1234567891011partition.xml - Everything begins with this file, which describes the number of partitions desired, and how many sectors each one should be.PartitioningTool.py - translates partition.xml into binary partitionsmsp.exe - writes binary partitions to SD/eMMC cards using card readermjsdload.cmm - writes binary partitions to SD/eMMC cards using Trace32msp.py - writes binary partitions to a single image fileQPST - writes binary partitions to SD/eMMC cards on TargetparseBinaryPartitionFile.pl - Decodes MBR partition tables. Run: &quot;Perl parseBinaryPartitionFile.pl partition.bin&quot; to generate the partition informationparseGPT.pl - Decodes GPT partition tables eMMC Partition tools usage for msm7x30/msm8x60 ¶ ptool.py python ptool.py –x partition.xml 这些工具源于高通的 modem 源码，当然是闭源的了： 12345678910boot_images/core/storage/tools/ptool/ptool.py //分区生成工具 partition =========&gt; rawprogram0.xml Python ptool.py –x partition.xml:msp.py //ubuntu使用：根据 rawprogram0.xml进行升级软件工具singleimage.py //根据singleimage_partition_8974.xml生成single boot image: 8974_msimage.mbn, python singleimage.py -x singleimage_partition_8974.xmllsusb.py // ls usbdd.py // dd commandchecksparse.py //sparse system/cache/userdata image[checksparse.py的使用](http://kernel-develop.blogspot.com/2012/06/emmc-sparse-image-download-in-msm8x60.html) 一个整合的工具，包括刷机命令行刷机的 qdload.pl aries-image-builder ¶ 文件说明 8x10_msimage.mbn ----平台镜像，是个完整的最小系统启动镜像，包括 sbl，tz，sdi，rpm 等必要启动分区和分区表 MPRG8x10.hex ----对应平台的串口烧写协议 gpt_both0.bin ----对应 EMMC 的分区表，因为不同批次的 EMMC 大小有细微差别，这个分区表不包含最后一个分区信息 rawprogram0.xml ----要烧写的具体文件跟对应的扇区位置 patch0.xml ----刷机软件根据手机服务端返回的具体磁盘大小打上最后一个分区的补丁、完成分区表头校验的配置文件，没有正确的 patch0.xml 分区表头就不能通过校验，手机也启动不了 8x10_msimage.mbn、MPRG8x10.hex 是通用的并可以在网上直接获取，单让手机进入磁盘模式，只需要 msimage 和 MPRG 即可。 ¶ msimage 生成 生成自己的 msimage.mbn，在 msm7k 平台需要 MBR0.bin 和 qcsblhd_cfgdata.mbn/qcsbl.mbn/oemsblhd.mbn/oemsbl.mbn 或者完整的 dbl/osbl。 在 msm8k 平台后需要 gpt，sbl1/sbl2/sbl3/rpm/tz。并不建议自己生成 msimage，防止成真砖。 ¶ Win(未验证） How to generate the 8660_msimage.mbn How to build eMMC flash programmer MPRG7x30.hex and 7x30_msimage.mbn emmcswdownload.exe -f 8660_msimage.mbn -x partition_boot.xml -s 16G 注意现在新版的 QPST，也只支持由 rawprogram0.xml 来生成 msimage 了。 ¶ Linux How to generate the 7x30_msimage.mbn python msp.py -r rawprogram0.xml -d 2048 生成 2048Kb，rawprogram0.xml 和其它一些文件如分区 mbr gpt 等是由上面所提到的 ptool.py 生成.这个 rawprogram0.xml 只需要包含生成 msimage 的必须项即可，可以手动直接修改，也可以修改 partition.xml，添加更多的启动分区命名成上面提到的 partition_boot.xml，然后再生成 rawprogram0.xml。 添加更多的分区，只要有该分区的镜像或者备份即可，比如包含 bootloader，这样有可能就可以直接启动到 bootloader 模式下刷机了，或者 NON-HLOS 等，或者一个完整的 rawprogram0.xml，这就相当于直接刷机了，但是这样生成的 msimage 将会非常大，刷起来非常的慢。 ¶ edl 模式 就是常说的救砖模式，一般高通手机只要没有硬件问题,使用 QHSUSB DLOAD 模式一般都救的回来，使用的是高通的 sahara和 firehose 协议，是 msm8k 以后平台的协议标准，两种协议分别使用 eMMC Software Download 和 QFIL(Qualcomm Flash Image Loader) 刷机，这两个工具全部包括在高通的QPST中。在这两种协议下，在 9008 模式时烧写进去的大概只有五个文件，然后系统会进入 9006 模式，这个模式下系统会识别 qualcomm emmc 磁盘,此时就可以恢复各分区的备份，或者直接写入关键的系统分区备份(可以使用UltraISO/HDD Raw Copy Tools等工具)，这样就可以进入 recovery/bootloader 进行刷机，也可以使用 QFIL 或 Miflash 或 Msm8974 Download Tool等救砖工具一步完成。 在 msm7k 平台以前是没有 EDL 急救模式的，出了问题只能 JTAG。 备份的时候可以使用 dd 命令备份出整个磁盘，或者系统关键分区。或者使用emmc raw tool msimage MPRG 是 Sahara 协议下刷机的必需的，而 firehose 协议下的必须文件变成了 prog_emmc_firehose_platform.mbn，看文件就可以知道使用的是什么协议。而以前的例如 msm7k 平台有的使用的是 stream dload 协议，QPST 工具里面使用的是 Software Download，和 Sahara 协议相比，并不需要 msimage，也不需要 xml，只需要串口烧写协议如 eNPRG hex 和 dbl/osbl，实际上 Sahara 协议所使用的 msimage 刚好是 dbl/osbl 的结合体，so，prog_emmc_firehose_platform.mbn也是 msimage 和 MPRG hex 的结合体？ stream dload 协议救砖方法: How to program eMMC images into blank flash with USB only in MSM7630 qualcomm 8K平台Sahara Protocol相对7K, 6K 平台Software Download优点 总结就是：8k Sahara Protocol省去了 CRC，打包、解包的过程直接传输 raw data，效率高。 同样的使用此模式刷机可以绕过华为的 MD5withRSA 的签名校验。 一般手机都有特别的按键方式进入,例如 vol+ &amp; usb 等等 使用 adb reboot edl 或者 adb reboot dload 或者 fastboot oem reboot-edl 清除tz分区 cat /dev/zero &gt; /dev/block/platform/msm_sdcc.1/by-name/tz 或者其它重要的分区如 sbl 分区、aboot 分区，也可在 fastboot 下直接 erase 当只能被识别为 9006 模式时，如果想切换到 9008，可以使用磁盘管理工具重建分区表，或者删除关键分区 拆机，短接测试点：把电信卡槽上面的金属片跟测试点连在一起，测试点要拆机才能看到（彻底黑砖的用这个方法） ¶ QFIL Command Line 12345qfil.exe -Mode=1 -COM="enter your comport number setting here" -SEARCHPATH="enter your complete path to 8675_W00 folder" -Sahara=true;"enter your complete path to the prog_emmc_FireHose_8936.mbn" -RawProgram=rawprogram0.xml -patch=patch0.xml -AckRawDataEveryNumPackets=TRUE;100 -DeviceTYPE="eMMC" -PlatForm="8x26" -MaxPayloadSizeToTargetInBytes="49152"Here are example to use itqfil.exe -Mode=1 -COM=64 -SEARCHPATH="D:\CBW8600A01_A_T1701" -Sahara=true;"D:\CBW8600A01_A_T1701\prog_emmc_FireHose_8x26.mbn" -RawProgram=rawprogram_unsparse.xml,rawprogram2.xml -patch=patch0,patch2.xml -AckRawDataEveryNumPackets=TRUE;100 -DeviceTYPE="eMMC" -PlatForm="8x26" -MaxPayloadSizeToTargetInBytes="49152" 更多文档在 QPST 软件的目录中。 ¶ 华为免解锁 官方卡刷跟官方平台线刷都会校验每个字节，每个文件，每个镜像文件都是 CRC32k 算法校验的，这是公开的。还有就是华为为防止文件的数据被修改还加了 MD5withRSA 加密算法，这个需要华为的私钥文件才能校验成功，私钥只有华为知道。 ¶ 解锁方法 官方申请解锁码 将其它手机解完锁后的 oeminfo.img 写入 oeminfo 分区,进行强制解锁,但是IMEI之类的貌似就是别人的了 使用 edl 模式,刷入修改后的 oeminfo 分区镜像,或者直接修改 echo -ne '\x02' | dd of=/dev/block/mmcblk0p3 bs=1 seek=33669144 conv=notrunc TUTORIAL: Remove TAMPERED &amp; RELOCKED flag 沃日，华为的解锁原理竟是如此的简单 十六个U是什么鬼,配合特定的机型,特定的 ROM 版本(efi fastboot),可实现解锁? 华为的手机存在解锁后没法降级的情况,就算重新锁上也是不行的.可以 dd if=/dev/urandom of=/dev/block/mmcblk0p8 bs=512 count=10 向 oeminfo 分区写入随机数据(记得备份),重启后 bootloader 就会重新锁上，就可以自由升降级了。 ¶ 参考 高通 MSM8K bootloader [教程] 高通平台线刷ROM制作简明教程，暴力ROOT IM-A820L显示QHSUSB_DLOAD的救砖方案 A840S黑砖修复过程 泛泰SKYA850救砖原理与分区表解析 泛泰SKYA850黑砖QHSUSB_DLOAD救砖教程 SHV-E160L Debricking Tool / Qualcomm Tool Pack V2-1 [REF][R&amp;D] Building Bootloaders on Qualcomm Devices [R&amp;D][QUALCOMM] Using QDL, EHostDL and DIAG interfaces &amp; features [PROJECT] Reviving Hard Bricked YU (QLoader 9008 Mode) Flashtools (MiFlash4Linux, Recovery from QDL/DLOAD, Partition resize)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>EDL</tag>
        <tag>DLOAD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015夏稻城亚丁]]></title>
    <url>%2F2015%2F07%2F11%2Fyading%2F</url>
    <content type="text"><![CDATA[稻城亚丁仙乃日神山，摄于2015年夏318之行]]></content>
      <categories>
        <category>相册</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt-x86 笔记]]></title>
    <url>%2F2015%2F03%2F09%2Fopenwrt-x86-note%2F</url>
    <content type="text"><![CDATA[此乃 OpenWrt-x86 编译时的笔记，很乱、不够系统，但以后完善 ¶ 目标硬件 Intel NUC D34010WYK 4g 内存 60g SSD Intel N2230无线网卡 ¶ x86 编译注意事项 大内存支持 多核心，多线程支持 sata drive 支持 网卡、wifi 驱动的集成 对 usb，例如鼠标、键盘的支持 编译所有文件系统支持，包括 ext2/ext3/ext4，还有 NTFS，甚至是 LVM； 加入一个文本编辑器，例如 vim 或者 nano，因为日常使用中需要用文本编辑器修改各种配置文件； 加入所有关于无线网卡的驱动，模块，各种支持程序， 一些其他常见应用–蓝牙、加密、PGP、SSL、SSH、VPN、USB支持、3G上网卡 ¶ Convert OpenWrt raw image gunzip openwrt.img.gz VBoxManage convertfromraw --format VDI openwrt.img openwrt.vdi ¶ Compile make menuconfig make kernel_menuconfig ¶ 真机使用注意事项 在 bios 中对 ide、sata 的修改 ¶ 编译流程 ¶ 流程 ./scripts/feeds update -a ./scripts/feeds install -a 检查编译环境，若可进行编译则生成默认配置 make defconfig make menuconfig 若有需求，则可以 make kernel_menuconfig make -j32 V=99，编译过程中会联网下载一些 package 编译完成的文件，在 bin/x86 目录下，可以烧写到U盘中测试。 how to build ¶ 单独编译某个包 123make packages/xxx/cleanmake packages/xxx/compilemake packages/xxx/install ¶ 未完成的工作 配置 wifi 热点的自动开启 音频、视频的支持 电源键的支持 U盘的自动挂载 3g/4g 上网卡的支持 对 sata 的支持 编译过程和后期的一些配置参考 ¶ Gargoyle 的编译 ¶ 如果有目标硬件 make FULL_BUILD=ture brcm47xx make brcm47xx 是rebuild ¶ 自由定制 make custom，上述命令会自动调用 make menuconfig配置菜单，但是第二次执行时就会跳过配置界面，所以要make FULL_BUILD=true custom ¶ 首次配置的方法 设备成功启动后，连接到该 AP 上，telnet 到 192.168.1.1,输入 passwd，设置密码后，才能使用 ssh 登陆，然后配置网络即可。如果设备启动失败，只有连接显示器查看原因了。 ¶ 一些软件的安装 ¶ 安装 luci 12345opkg updateopkg intsall luci安装完毕记得启动luci./etc/init.d/uhttpd enable./etc/init.d/uhttpd start 12345678910111213opkg install kmod-usb-coreopkg install kmod-usb-ohci #安装usb ohci控制器驱动opkg install kmod-usb-uhci #UHCI USB控制器opkg install kmod-usb2 #安装usb2.0opkg install kmod-usb-storage #安装usb存储设备驱动opkg install kmod-fs-ext3 #安装ext3分区格式支持组件opkg install mount-utils #挂载卸载工具opkg install ntfs-3g #挂载NTFSopkg install kmod-fs-vfat #挂载FATopkg install block-mountopkg install fdisk opkg install usbutils #安装了这个后可以用 lsusbopkg install pciutils ¶ 具体配置 12345678910111213141516171819202122Target System (x86) #目标平台选择,这里选择X86，如果非x86系统下面需要选择TargetImages ---&gt;ext4 #生成.EXT4.IMG文件[0] seconds to wait befor booting the default entry #启动不等待5秒Base system ---&gt;&lt;*&gt; block-mount #以后挂载USB用kernel modules ---&gt; Block Devices ---&gt; 这项用于支持磁盘 &lt;*&gt; kmod-ata-core #支持SATA硬盘 &lt;*&gt; kmod-ata-ahci &lt;*&gt; kmod-loop Filesystems ---&gt; &lt;*&gt; kmod-fs-ext4 NativeLanguage Support ---&gt; #语言支持 &lt;*&gt; kmod-nls-iso8859-1 &lt;*&gt; kmod-nls-utf8 Network Devices ---&gt; #网卡驱动，必须添加自己需要的网卡驱动 &lt;*&gt; kmod-macvlan Wireless Drivers ---&gt; #wifi卡驱动，添加自己需要的Luci-----Collection----luciTranslation---luci-i18n-chinese 12345Input modules ---&gt;#键盘 -*- kmod-hid &lt;*&gt; kmod-hid-generic -*- kmod-input-core -*- kmod-input-evdev 123456789101112Kernel modules: USB Support: &lt;*&gt; Kmod-usb-storage Filesystems: &lt;*&gt; Kmod-fs-ext3Base system: &lt;*&gt; Block-extrootUtilities: Filesystem: &lt;*&gt; E2fsprogs Disc: &lt;*&gt; Fdisk &gt; 12345678Processor type and features ---&gt; [*] Symmetric multi-processing support Processor family (Core 2/newer Xeon) ---&gt;#自行选择处理器平台 [*] Supported processor vendors ---&gt;#自行选择处理器平台 (2) Maximum number of CPUs #自行编辑 [*] SMT (Hyperthreading) scheduler support#超线程支持 [*] Multi-core scheduler support High Memory Support (4GB) ---&gt; 若使用U盘测试，还需配置 12Target Images ---&gt; (/dev/sda2) Root partition on target device (NEW) #修改 /dev/sda2 为 /dev/sdb2 ¶ 对 freeswitch 的集成 目前的两种方法 直接把 freeswitch 的源码目录放到 openwrt 的 package 目录中， 做为一个单独的 git 项目，使用该 package 时修改 feeds.conf 添加订阅，然后在 make menuconfig 时选择 freeswitch 模块。 无论这两种方法，都需要在 freeswith 中增加 package/Makefile [必备] package/patches/ [可选] package/files/ [可选] patches 目录和files 目录都是可选的，patches 目录通常包括 bug 修复和对可执行文件体积的优化，files 目录通常包括配置文件。 ¶ Makefile文件 PKG_NAME -软件包的名字, 在 menuconfig 和 ipkg 显示 PKG_VERSION -软件包的版本，主干分支的版本正是我们要下载的 PKG_RELEASE -这个 makefile 的版本 PKG_BUILD_DIR -编译软件包的目录 PKG_SOURCE -要下载的软件包的名字，一般是由 PKG_NAME 和 PKG_VERSION 组成 PKG_SOURCE_URL -下载这个软件包的链接 PKG_MD5SUM -软件包的 MD5 值 PKG_CAT -解压软件包的方法 (zcat, bzcat, unzip) PKG_BUILD_DEPENDS -需要预先构建的软件包，但只是在构建本软件包时，而不是运行的的语法和下面的 DEPENDS 一样。 ¶ 参考 创建软件包 configure FreeSWITCH to run on their OpenWrt]]></content>
      <categories>
        <category>Openwrt</category>
      </categories>
      <tags>
        <tag>Openwrt-x86</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 12.04 安装搜狗拼音输入法]]></title>
    <url>%2F2014%2F05%2F19%2Fubuntu12.04-install-sogoupinyin%2F</url>
    <content type="text"><![CDATA[新出的linux下的搜狗输入法，颇感兴趣，这里作为记录。 ¶ 安装fcitx ubuntu12.04默认源中的fcitx版本较旧，安装新版本的fcitx。 sudo add-apt-repository ppa:fcitx-team/nightly sudo apt-get update 如果已经安装了旧版本的fctix，更新: sudo apt-get upgrade 更新后，需重启或注销重新登陆。 未安装，直接安装： sudo apt-get install fcitx 安装googlepinyin和sunpinyin（个人习惯，作为备用）： sudo apt-get install fcitx-googlepinyin sudo apt-get install fcitx-sunpinyin 切换输入法框架为fcitx： im-switch -s fcitx ¶ 卸载ibus ibus和fcitx共存时老有一些莫名其妙的bug，所以卸载ibus。 killall ibus-daemon sudo apt-get autoremove ibus ibus-sunpinyin 如果你使用的桌面是gnome，请暂时先不要卸载ibus-gtk3，据说会导致进步了系统。 如果上一步没有重启过，重启或者注销重新登陆。 ¶ 安装搜狗拼音 下载安装 ¶ 遇到的问题 小企鹅右键设置启用搜狗pinyin，输入的时候提示： 請啓用fcitx-qimpanel面板程序，以便更好的享受搜狗輸入法！ 解决办法： 重启 fcitx 切换到 qimpanel，同时开启 qimpanel fcitx -r --enable fcitx-qimpanel fcitx-qimpanel 有时重启系统后，输入法没有输入框的现象，只能盲打，我的解决办法是kill掉fcitx-qimpanel，然后重新启动，不可以的话就多kill掉几次ps -ef | grep qim。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime_text 支持中文输入]]></title>
    <url>%2F2014%2F05%2F19%2Fsublime-support-chinese-im%2F</url>
    <content type="text"><![CDATA[让sublime_text支持中文输入，这在ubuntu上是一直不可以的，以前用过插件来达到中文你输入的目的，不过太繁琐。 ¶ 安装编译所需依赖 sudo apt-get install build-essential libgtk2.0-dev ¶ 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*sublime-imfix.cUse LD_PRELOAD to interpose some function to fix sublime input method support for linux.By Cjacker Huang &lt;jianzhong.huang at i-soft.com.cn&gt;gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPICLD_PRELOAD=./libsublime-imfix.so sublime_text*/#include &lt;gtk/gtk.h&gt;#include &lt;gdk/gdkx.h&gt;typedef GdkSegment GdkRegionBox;struct _GdkRegion&#123; long size; long numRects; GdkRegionBox *rects; GdkRegionBox extents;&#125;;GtkIMContext *local_context;voidgdk_region_get_clipbox (const GdkRegion *region, GdkRectangle *rectangle)&#123; g_return_if_fail (region != NULL); g_return_if_fail (rectangle != NULL); rectangle-&gt;x = region-&gt;extents.x1; rectangle-&gt;y = region-&gt;extents.y1; rectangle-&gt;width = region-&gt;extents.x2 - region-&gt;extents.x1; rectangle-&gt;height = region-&gt;extents.y2 - region-&gt;extents.y1; GdkRectangle rect; rect.x = rectangle-&gt;x; rect.y = rectangle-&gt;y; rect.width = 0; rect.height = rectangle-&gt;height; //The caret width is 2; //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret. if(rectangle-&gt;width == 2 &amp;&amp; GTK_IS_IM_CONTEXT(local_context)) &#123; gtk_im_context_set_cursor_location(local_context, rectangle); &#125;&#125;//this is needed, for example, if you input something in file dialog and return back the edit area//context will lost, so here we set it again.static GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context)&#123; XEvent *xev = (XEvent *)xevent; if(xev-&gt;type == KeyRelease &amp;&amp; GTK_IS_IM_CONTEXT(im_context)) &#123; GdkWindow * win = g_object_get_data(G_OBJECT(im_context),"window"); if(GDK_IS_WINDOW(win)) gtk_im_context_set_client_window(im_context, win); &#125; return GDK_FILTER_CONTINUE;&#125;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window)bbbbbbbb klass-&gt;set_client_window (context, window); if(!GDK_IS_WINDOW (window)) return; g_object_set_data(G_OBJECT(context),"window",window); int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) &#123; gtk_im_context_focus_in(context); local_context = context; &#125; gdk_window_add_filter (window, event_filter, context);&#125; ¶ 编译 gcc -shared -o libsublime-imfix.so sublime_imfix.cpkg-config --libs --cflags gtk±2.0-fPIC ¶ 启动sublime LD_PRELOAD=./libsublime-imfix.so subl ¶ 添加到默认启动 查看sublime-text所在文件夹： 12which sublvi /usr/bin/subl 复制libsublime-imfix.so到sublime所在文件夹： sudo cp libsublime-imfix.so /opt/sublime_text ¶ 方法一 1234cd /usr/bin/sudo touch sublime_text3 sudo chmod a+x sublime_text3sudo vi sublime_text3 添加内容： 1234#!/bin/bashSUBLIME_HOME="/opt/sublime_text"LD_LIB=$SUBLIME_HOME/libsublime-imfix.sosh -c "LD_PRELOAD=$LD_LIB $SUBLIME_HOME/sublime_text $@" 保存退出。 编辑/usr/share/applications将其中的三处/opt/sublime_text/sublime_text修改为/usr/bin/sublime_text3。 这样无论在终端中执行sublime_text3还是双击或者右键打开文本都可以输入中文了。 ¶ 方法二 编辑/usr/bin/subl，在最后一行上面添加： export LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so 编辑/usr/share/applications将其中的三处/opt/sublime_text/sublime_text替换为/usr/bin/subl ¶ 参考 Input method support]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Sublime text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Jenkins 编译 nightly version rom]]></title>
    <url>%2F2014%2F04%2F22%2Fjekins_CI_build_rom%2F</url>
    <content type="text"><![CDATA[使用CI(持续集成)jekins编译nightly版的ROM ¶ 安装apache sudo apt-get install apache2 ¶ 安装jenkins 切换到root用户下: echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list 切回用户: apt-get update &amp;&amp; apt-get install jenkins ¶ 其它 重启服务命令: /etc/init.d/jenkins restart 安装完成后,系统中添加了一个用户jenkins,不要尝试修改该用户的密码. /var/lib/jenkins下面的文件都是jenkins用户的,对jenkins来说,这个目录就是它的home目录,所以修改这个下面的文件时注意文件的拥有者. sudo su - jenkins 可以切换到该用户. 访问localhost:8080,首先要做的就是添加一个用户所用权限的用户，然后使用该用户sign up。 jenkins的配置文件在/etc/default/jenkins. ¶ Setting up the job To use Jenkins to build regular nightlies for multiple devices, follow this quick steps: Prepare your Android source tree Create a new job, as a multi-configuration project In Advanced Project Options, check “Custom workspace”, and point both the Directory and Directory for sub-builds to the root of your Android tree Add a new user-defined axis to the matrix, and call it ‘device’. In values, you must put each device you want to build, separated by spaces (e.g. ‘mako manta flo deb’). Check ‘Run each configuration sequentially’ Add a new ‘Execute shell’ build step, in order to run a short build script. In Omni’s case we have a script at the root of our workspace, thus we put ‘./build_nightly.sh $device’, where $device will be replaced by each device for each build. Save the job, you’re all set. Create then your build script. Here’s Omni build script: #!/bin/bash export USE_CCACHE=1 export CCACHE_DIR=/home/build/.ccache export BUILDTYPE_NIGHTLY=1 DEVICE=$* cd /home/build/omni . build/envsetup.sh repo sync -j48 rm -rf out/target brunch $DEVICE ¶ Adding a device to a nightly job Just add the device code into the ‘device’ axis in the job settings. ¶ 遇到的问题 当脚本被触发运行时,使用的jenkins用户的环境变量,会出现找不到环境变量,和许多的权限问题.最后的解决方法是,新建一个节点,指向本机IP和workspace,以ssh登录即可. ¶ 参考 Setting up Jenkins for building nightlies HOW TO AUTOMATE YOUR ROM BUILDING PROCESS]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将 Sublime Text 2 设置为默认编辑器]]></title>
    <url>%2F2013%2F11%2F22%2Fset-sublimetext-to-default-editor%2F</url>
    <content type="text"><![CDATA[虽然一直在用Sublime Text 2，但是一直比较懒，没有将其设置为默认编辑器。 ¶ 修改defaults.list 编辑/etc/gnome/default.list文件，将其中的所有gedit.desktop替换为sublime-text-2.desktop。 sublime-text-2.desktop在/usr/share/applications/目录下，使用ls -al *sublime*命令查看具体文件名。 ¶ 配置alternatives 执行： sudo update-alternatives --install /usr/bin/gnome-text-editor gnome-text-editor /usr/bin/sublime-text 300 sublime-text在/usr/bin目录下，是一个可执行二进制文件。 然后： sudo update-alternatives --config gnome-text-editor 输入sublime-text那一行的行数就行了。 OK!]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Sublime text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译极路由的 OpenWRT 固件]]></title>
    <url>%2F2013%2F11%2F12%2Fopenwrt-for-hiwifi%2F</url>
    <content type="text"><![CDATA[虽然被坑了，看习惯了塑料外壳的个子老大的路由器，看一下小巧金属外壳的hiwifi还是很养眼的。从来没有接触过路由器固件的相关信息，现在有机会了，了解一下还是很好的，弄个下载机什么的。 ¶ 吐槽一下 极路由真是太坑爹了，照着小米学，学得不到家。最后真正成了欺骗用户了，虽然自己也是受害者。 知乎上有很好的回答，可惜近日已经删除了，不过还是能看出点什么的。 如何评价极路由公司 2013 年 11 月发布的「极贰」路由器？ 为什么网络上极路由的负面评价那么多？ 虽然被坑了，看习惯了塑料外壳的个子老大的路由器，看一下小巧金属外壳的hiwifi还是很养眼的。 从来没有接触过路由器固件的相关信息，现在有机会了，了解一下还是很好的，弄个下载机什么的。 ¶ 编译hiwifi的openwrt固件 ¶ 环境准备 至于环境就没啥好准备的了，自己的电脑编译环境还是很全的。 不过，hiwifi的代码是用svn管理的，从没有用过svn，还是先装一个。 sudo apt-get install subversion git ¶ 获取源码 svn co https://code.hiwifi.com/svn/hiwifi 遇到提示输入密码时，直接打回车，然后出来输入用户名的提示，输入极客社区帐号email，再输入密码。 ¶ 编译 cd hiwifi/trunk ./scripts/feeds update -a ./scripts/feeds install -a make package/symlinks ¶ 使用默认的编译选项 make HC6361_defconfig ¶ 也可以自定义编译选项（这才是精华所在） make menuconfig 可以把openssh、python、pythonopenssl、unbound等，都配置进去。 最后： make -j4 如果出错，要查看详细的编译信息可以使用V=s参数: make -j4 V=s 开始漫长的编译。 ¶ 制作成recovery.bin wget -O rom.bin http://updaterom.ikcd.net/upgrade_file/HC6361-0.775.784s_130802-131633-96d56f0c dd if=rom.bin of=uboot.bin bs=1k count=128 cat uboot.bin bin/ar71xx/openwrt-ar71xx-generic-tw150v1-squashfs-sysupgrade.bin &gt;recovery.bin 上面的链接404，暂时的解决方法是跳过wget，手动下载官方的一个recovery.bin，重命名为rom.bin然后执行下面的命令提取uboot.bin。 ¶ 刷机 去这里下载官方开源版本固件，解压 将上一步生成的recovery.bin替换目录中recovery.bin 用网线将极路由 LAN 口与电脑网口相连 将电脑网络接口 IP 设置为 192.168.1.88/255.255.255.0 用尖锐物按住极路由 RESET 不放，给极路由加电 等待电脑上 tftpd 出现传输 recovery.bin 进度条完成后，松开 RESET 极路由面板灯进入跑马灯状态，跑完后，系统自动重启，刷机完成 ¶ 参考，扩展阅读 极路由的正确玩法 OpenWrt安装goagent实例教程 Openwrt架设DNS转发器，解决污染问题 openwrt-hiwifi]]></content>
      <categories>
        <category>Openwrt</category>
      </categories>
      <tags>
        <tag>Hiwifi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下 mail 命令的使用]]></title>
    <url>%2F2013%2F10%2F31%2Flinux-send-mail%2F</url>
    <content type="text"><![CDATA[因为服务器上 android 项目的一个编译脚本，要检测编译的状况。要增加一个发送 email 的功能，可以以前没有用过，就研究一下。 ¶ 安装 安装 mailutils sudo apt-get install mailutils 因为还要发送附件，需安装 sudo apt-get install sharutils ¶ 发送方式 ¶ 一般的发送方式 mail address@address.com 编辑抄送对象，邮件主题，邮件正文后，按 Ctrl-D 结束。 ¶ 快速发送方式 echo “邮件正文” | mail -s &quot;邮件主题&quot; address@address.com ¶ 以文件内容作为邮件正文来发送 mail -s &quot;邮件主题&quot; address@address.com &lt; 邮件正文.txt ¶ 发送带附件的邮件 uuencode 附件名称 附件显示名称 | mail -s &quot;邮件主题&quot; address@address.com 例如： uuencode test.txt test.txt | mail -s Test address@gmail.com ¶ 以文件内容作为邮件正文和同时发送附件 没有找到什么便利的方法 例： uuencode log.tar.gz log.tar.gz &gt; attachment.txt cat info.txt attachment.txt &gt; combined.txt mail -s &quot;服务器编译错误，请查看日志文件&quot; x2280854@gmail.com &lt; combined.txt 经测试，发送到 gmail 邮箱，邮件正文和附件是可以正确识别的。而发送到 163 的公司邮箱，无法正确识别，而是把整个 combined.txt 当作了正文。 ¶ 11.26 更新 ¶ 遇到的一个错误 最近一段时间服务器上的邮件，一直无法成功发送到我的邮箱，今天抽空看了一下。 /usr/lib/sendmail -bp 错误日志： 47DA518ADCE6 397 Tue Nov 26 14:40:39 shenduos@Raphael-DeepinLinux (Host or domain name not found. Name service error for name=gmail.com type=MX: Host not found, try again) x2280854@gmail.com 最后的问题在： /var/spool/postfix/etc/resolv.conf 编辑 /var/spool/postfix/etc/resolv.conf，文件内容应该和 /etc/resolv.conf 中一样。 ¶ 参考 Linux mail命令使用 linux下mail命令使用(转)]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git stash 的使用]]></title>
    <url>%2F2013%2F10%2F22%2Fgit-stash%2F</url>
    <content type="text"><![CDATA[对于有时某些未完善的修改，并不想commit时，而又有需求切换分支工作时，这时git stash命令就派上用场了 ¶ 搁置修改 有时在分支上有未提交的修改，因为要切到其它分支或要做其它修改测试，因修改未整理，不想提交。这时就可以使用stash命令，例： git add . git stash 这样把未提交的修改暂时搁置，所有文件恢复到未修改之前的，然后就可以进行其它的工作了 ¶ 恢复搁置的修改 恢复之前搁置的修改： git stash apply ¶ git stash 的其它命令 ¶ 查看所有之前搁置的修改 git stash list ¶ 恢复其中的某个修改 git stash apply stash@{1} #注意这是找回第二个 git stash pop #找回第一个 ¶ 删除某个stash git stash drop &lt;id&gt; ¶ 删除所有stash git stash clear]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Sublime Text 2 编辑 Markdown]]></title>
    <url>%2F2013%2F10%2F17%2Fsublime-text2-edit-markdown%2F</url>
    <content type="text"><![CDATA[Sublime Text 2 现在做为我的第一编辑器，用好它还需要一个漫长的过程。学习Markdown必须找一个合手的编辑器 ¶ Sublime Text 2的配置 这里使用了两个插件： MarkdownEditing Markdown Preview Markdown Preview是预览插件。安装过程，待以后补全。 ¶ Sublime Text 2的快捷键 Ctrl+Win+V 选中的内容将自动转换为行内式超链接，链接到剪贴板中的内容 Ctrl+Win+R 选中的内容将自动转换为参考式超链接，链接到剪贴板中的内容 Ctrl+Alt+R 弹出提示框插入一个参考式超链接，在提示框中输入链接内容和定义参考ID[^3] Ctrl+Win+K 插入一个标准的行内式超链接 Win+Shift+K 插入一个标准的行内式图片（此快捷键可能与输入法有冲突） Ctrl+1 至 Ctrl+6 插入一级至六级标题 Win+Alt+i 选中的内容转换为斜体 Win+Alt+b 选中的内容转换为粗体[^1] Ctrl+Shift+6 自动插入一个脚注，并跳转到该脚注的定义中。 Alt+Shift+F 查找没有定义的脚注并自动添加其定义链接 Alt+Shift+G 查找没有定义的参考式超链接并自动添加其定义链接 Ctrl+Alt+S 脚注排序 Ctrl+Shift+. 缩进当前内容 Ctrl+Shift+, 提前当前内容 ¶ 其它Ubuntu 下的Markdown 工具 ReTex mahua 其中第二个mahua是在线编辑器，都可以实现实时预览。 ¶ ReTex Ubuntu 13.04下安装过程 sudo add-apt-repository ppa:mitya57 sudo apt-get update sudo apt-get install retext ¶ 一个Markdown语法高亮主题 Monokai-custom.tmTheme 放到~/.config/sublime-text-2/Packages/User/ 文件夹下，在Preferences -&gt; Color Scheme -&gt; User选择Monokai-custom。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Sublime text</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将 WordPress 的数据迁移到 Jekyll]]></title>
    <url>%2F2013%2F10%2F16%2Fmigrate-wp-jekyll%2F</url>
    <content type="text"><![CDATA[遇到了太多的麻烦，整个重来了好几遍 官方文档: http://jekyllrb.com/docs/migrations/ 安装过程中出错，因为 ruby 版本太低，要更新版本到 1.9.2，因为先前的工作并没有更新 ruby 的版本，导致遇到了很多麻烦，所以重新来了一遍。更新 ruby 的方法，已经放到了第一篇文章中去了。 备份 wordpress 的文章: 进入 wordpress 的后台，工具-导出，导出文章即可，是一个 xml 文件 前期准备，这里使用从 xml 导出的方式，从数据库导出一直没有搞定 sudo gem install hpricot 这里使用别人修改好了的脚本，官方脚本对中文支持不友好： https://gist.github.com/chitsaou/1394128 将备份的 wordpress.xml 放到项目的根目录，把脚本放到新建的 utils 目录中，然后运行： sudo ruby -r &quot;./utils/wordpressdotcom.rb&quot; -e &quot;Jekyll::WordpressDotCom.process&quot; 因为边一直使用了 sudo，导致后来出了很多问题，不得不使用 sudo 才行。 转换好的文章在 source 目录中。 把 html 转换成 markdown 真是个力气活，最后还有手动纠正很多错误才行。]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 github 搭建静态博客]]></title>
    <url>%2F2013%2F10%2F14%2Fmy-first-post%2F</url>
    <content type="text"><![CDATA[这是首次使用 githubpages 的第一篇博文，也是一篇教程 ¶ 安装 Jekyll ¶ 更新 Ruby 版本 已弃用，请查看新方法 此环境需要 ruby 的版本 &gt;=1.9.2，ruby -v查看 ruby 的版本，如果版本低于 1.9.2，得更新 ruby curl -L https://get.rvm.io | bash -s stable --ruby 编辑 ~/.bashrc，将 ~/.bash_profile 中的文本复制到 .bashrc 末尾，然后更新环境变量： source ~/.bashrc 然后安装 1.9.2： rvm install 1.9.2 此时 ruby -v 查看版本 ruby 的版本默认为最新的，设置为默认的 1.9.2： rvm --default 1.9.2 也可以暂时调整使用其它版本如： rvm use 1.9.3 如果版本不对，请按照上诉步骤更新环境变量。 ¶ 新方法 以上方法虽然可以允许自定义但是很麻烦，使用的是 ubuntu13.04，源中有 ruby1.9.3 版本，直接安装，弃用以上方法。 sudo apt-get install ruby1.9.3 ¶ 安装 jekyll 为了在本地可以测试，直观的看到修改后的展示效果，需要安装 jekyll sudo apt-get install rubygems 然后使用 gem 命令安装以下包： sudo gem install jekyll sudo gem install rdiscount 国外的 gem 源，也许比较慢，可以更改 gem 的源（未测试） sudo gem sources --remove http://rubygems.org/ sudo gem sources -a http://ruby.taobao.org/ ¶ 创建项目 在你的 github 上创建一个项目 username.github.com， username 为你在 github 上的用户名，创建时可以初始化一个 readme.m d和 jekyll 的 .gitignore 文件 将你的项目 git clone 到本地 ¶ clone 一个模板 这里有很多 jekyll 的模板: https://github.com/mojombo/jekyll/wiki/sites clone 一个 Octopress 的模板:(有问题，木有搞定，换一个模板） git clone https://github.com/xuhdev/homepage.git 使用 https://github.com/beiyuu/beiyuu.github.com.git 这个模板 然后删除其中的 .git 文件，copy 到你的项目目录 ¶ 本地查看效果 在你的项目目录下执行: jekyll serve 如果没有什么错误发生的话，就可以在浏览器中浏览 localhost:4000 ¶ 开始自己的修改吧 测试没有问题的话，就可以开始自己的修改了。删除原来的文章，增加自己的文章，修改域名，博客标题， icon 等。本地测试一下没有问题的话，就可以 push 了。 下面就是开始努力的学习 markdown 语法了，这个东西对我最头痛排版的问题，简直是太爽 了，有种相见恨晚的赶脚。]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mt6589 增加新的项目]]></title>
    <url>%2F2013%2F09%2F30%2Fmt6589-add-new-project%2F</url>
    <content type="text"><![CDATA[从自己的笔记中，摘抄出来的，一直没有整理 只有使用自定义签名时才使用项目签名: 配置选项为: 123MTK_SIGNATURE_CUSTOMIZATION = yesMTK_INTERNAL = nocp -fr build/target/product/security/$old_p/ build/target/product/security/$new_p/ 其它: 12345cp -fr build/target/product/$old_p.mk build/target/product/$new_p.mkcp -fr mediatek/config/$old_p/ mediatek/config/$new_p/cp -fr mediatek/custom/$old_p/ mediatek/custom/$new_p/cp -fr vendor/mediatek/$old_p/ vendor/mediatek/$new_p/mv vendor/mediatek/$new_p/artifacts/out/target/product/$old_p vendor/mediatek/$new_p/artifacts/out/target/product/$new_p 还有 /vendor/mediatek/$project/artifacts/target.txt 修改里面的 $project 为 $new_p]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MTK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mt6589 禁用 Navigation Bar]]></title>
    <url>%2F2013%2F08%2F29%2Fmt6589-disable-navigation-bar%2F</url>
    <content type="text"><![CDATA[默认 Navigation Bar 的控制在 1&lt;bool name="config_showNavigationBar"&gt;true&lt;/bool&gt; alps/frameworks/base/core/res/res/values/config.xml 文件中 6589 navigation Bar 最终控制在，会覆盖掉上述设置： alps/mediatek/custom/project_name/resource_overlay/generic/frameworks/base/core/res/res/values/config.xml 所以主要修改 config 中的 overlay 为 false。 但是有的在 build.prop 中又定义了 qemu.hw.mainkeys，可以在 config 中的 system.prop 中去掉，或者改为 qemu.hw.mainkeys=1。如果 buildinfo.sh 中有此定义，也可以修改掉]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MTK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恢复删除的分支、或者丢失的 commit]]></title>
    <url>%2F2013%2F08%2F12%2Frecover-deleted-branches-lost-commit%2F</url>
    <content type="text"><![CDATA[手一哆嗦把分支删掉了，干掉了好几天的工作成果，不甘心。谁让咱git使用没那么牛呢，遂找办法。还是把《git权威指南》细细看完吧。 转自：http://sumsung753.blog.163.com/blog/static/146364501201301711943864/ 在使用Git的过程中，有时可能会有一些误操作 比如：执行checkout -f 或 reset -hard 或 branch -d删除一个分支 结果造成本地（远程）的分支或某些commit丢失 可以通过reflog来进行恢复，前提是丢失的分支或commit信息没有被git gc清除 一般情况下，gc对那些无用的object会保留很长时间后才清除的 reflog是git提供的一个内部工具，用于记录对git仓库进行的各种操作 可以使用git reflog show或git log -g命令来看到所有的操作日志 恢复的过程很简单： 通过git log -g 命令来找到我们需要恢复的信息对应的commit_id，可以通过提交的时间和日期来辨别。一个好的办法是运行： git log --since=“2 weeks ago” – myfile #可以查看2个星期期间的myfile历史 git log --branches=“developer” #可以查看某个developer的commit 通过git branch recover_branch[新分支] commit_id 来建立一个新的分支 这样，我们就把丢失的东西给恢复到了recover_branch分支上了。 Q:如果是不小心执行了git reset，还有办法取消吗？ A:git reflog 查看操作历史，找到之前 HEAD 的 hash 值，然后 git reset --hard 到那个 hash 即可。 Q:怎样找回历史版本中删除的文件？ A:先确定需要恢复的文件要恢复成哪一个历史版本(commit)，假设那个版本号是： commit_id，那么 git checkout [commit_id] — &lt;path_to_file&gt; 就可以恢复。]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 13.04 上搭建LAMP本地服务器]]></title>
    <url>%2F2013%2F06%2F24%2Fubuntu13-04-build-local-server-lamp%2F</url>
    <content type="text"><![CDATA[这是以前的一篇在本地测试用的 ¶ 安装 ¶ 安装MYSQL sudo apt-get install mysql-server sudo apt-get install mysql-client 安装mysql-server的过程中需要设置root用户的密码 ¶ 安装Apache sudo apt-get install apache2 ¶ 安装PHP sudo apt-get install php5 sudo apt-get install libapache2-mod-auth-mysql sudo apt-get install php5-mysql ¶ 安装phpMyadmin sudo apt-get install phpmyadmin sudo ln -s /usr/share/phpmyadmin 安装过程中配置phpMyadmin，服务器要选择apache。需要输入数据库的登陆密码，并设置phpMyadmin的登陆密码 ¶ 测试 ¶ 修改权限 chown username /var/www（将username替换为您当前用户的用户名） chmod 777 /var/www/ ¶ 检测Mysql是否正常 在终端中输入： mysql -uroot -p 输入密码，看是否可正常登陆 ¶ 检测Apache是否正常 在浏览器中打开：http://localhost/ 如果出现如下信息，则表明正常。 It works! This is the default web page for this server. The web server software is running but no content has been added, yet. ¶ 检测PHP是否正常 Ubuntu下Apache的默认安装路径为/var/www/，到其目录下新建info.php文件，文件内容为： 然后在浏览器中打开：http://localhost/info.php 看是否正常。 ¶ 检查phpMyadmin是否正常 在浏览器中访问http://localhost/phpmyadmin，到phpMyAdmin的登陆界面 重启apache服务器： 做完一些修改后有时要重启一下： sudo /etc/init.d/apache2 restart]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 13.04 gcc 版本降级]]></title>
    <url>%2F2013%2F05%2F30%2Fubunt13-04-gcc-downgrade%2F</url>
    <content type="text"><![CDATA[遇到的一个问题： 在ubuntu中安装完virtualbox，启动时出错，按照提示执行： sudo /etc/init.d/vboxdrv setup 再模块加载时出了一个错： 1* Modprobe vboxdrv failed. Please use &apos;dmesg&apos; to find out why. 查看log，/var/log/vbox-install.log，怀疑是gcc的问题 遂将gcc版本升级为4.7，再次执行 1sudo /etc/init.d/vboxdrv setup 时成功通过，并启动。然后又将gcc版本降为4.4。 ubuntu13.04 的 gcc 版本是 4.7.3 的，防止以后编译时因版本太高而出现的编译错误，将版本降为 4.4. 查看版本： 1gcc -v 安装gcc4.4： 1sudo apt-get install g++-4.4-multilib gcc-4.4-multilib 注意软链： 12ls /usr/bin/gcc* -lls /usr/bin/g++* -l 修改软链: 123cd /usr/bin/sudo mv gcc gcc.baksudo ln -s gcc-4.4 gcc 同样的修改g++： 12sudo mv g++ g++.baksudo ln -s g++-4.4 g++ 再次查看版本号，OK]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>GCC</tag>
      </tags>
  </entry>
</search>
